"""
Tool scaffold generator implementation.
"""

from __future__ import annotations

from pathlib import Path

USER_TOOLS_DIR = Path.home() / ".l3m" / "tools"

# Template for a basic tool
BASIC_TOOL_TEMPLATE = '''"""
{tool_name} - User-defined tool for l3m-backend.

Generated by: l3m-tools create {tool_name}
"""

from typing import Any

from l3m_backend.core import tool_output
from l3m_backend.tools import registry


@registry.register(aliases=["{alias}"])
@tool_output(llm_format="{{result}}")
def {function_name}(
    input: str,
) -> dict[str, Any]:
    """
    {description}

    Args:
        input: The input to process.

    Returns:
        Dictionary with 'result' key containing the output.
    """
    # TODO: Implement your tool logic here
    return {{
        "result": f"Processed: {{input}}",
    }}
'''

# Template for a command wrapper tool (simple - no custom args)
WRAPPER_TOOL_TEMPLATE = '''"""
{tool_name} - Wrapper tool for `{command}`.

Generated by: l3m-tools create {tool_name} --wrap "{command}"
"""

import subprocess
from typing import Any

from l3m_backend.core import tool_output
from l3m_backend.tools import registry


@registry.register(aliases=["{alias}"])
@tool_output(llm_format="{{output}}")
def {function_name}(
    args: str = "",
    timeout: int = 30,
) -> dict[str, Any]:
    """
    Run `{command}` with the given arguments.

    Args:
        args: Arguments to pass to the command.
        timeout: Maximum execution time in seconds (default: 30, max: 60).

    Returns:
        Dictionary with stdout/stderr output and exit code.
    """
    timeout = min(timeout, 60)  # Cap at 60 seconds

    try:
        cmd = f"{command} {{args}}" if args else "{command}"
        result = subprocess.run(
            cmd,
            shell=True,
            capture_output=True,
            text=True,
            timeout=timeout,
        )

        output = result.stdout
        if result.stderr:
            output += f"\\nSTDERR:\\n{{result.stderr}}" if output else result.stderr

        return {{
            "output": output.strip() or "(no output)",
            "exit_code": result.returncode,
        }}
    except subprocess.TimeoutExpired:
        return {{"error": f"Command timed out after {{timeout}} seconds"}}
    except Exception as e:
        return {{"error": str(e)}}
'''

# Template for a command wrapper tool with custom arguments
WRAPPER_ARGS_TOOL_TEMPLATE = '''"""
{tool_name} - Wrapper tool for `{command}`.

Generated by: l3m-tools create {tool_name} --wrap "{command}" {arg_flags}
"""

import subprocess
from typing import Any

from l3m_backend.core import tool_output
from l3m_backend.tools import registry


@registry.register(aliases=["{alias}"])
@tool_output(llm_format="{{output}}")
def {function_name}(
{params}
    timeout: int = 30,
) -> dict[str, Any]:
    """
    Run `{command}` with arguments.

    Args:
{docstring_args}
        timeout: Maximum execution time in seconds (default: 30, max: 60).

    Returns:
        Dictionary with stdout/stderr output and exit code.
    """
    timeout = min(timeout, 60)  # Cap at 60 seconds

    try:
        cmd = f"{command} {cmd_args}"
        result = subprocess.run(
            cmd,
            shell=True,
            capture_output=True,
            text=True,
            timeout=timeout,
        )

        output = result.stdout
        if result.stderr:
            output += f"\\nSTDERR:\\n{{result.stderr}}" if output else result.stderr

        return {{
            "output": output.strip() or "(no output)",
            "exit_code": result.returncode,
        }}
    except subprocess.TimeoutExpired:
        return {{"error": f"Command timed out after {{timeout}} seconds"}}
    except Exception as e:
        return {{"error": str(e)}}
'''


def generate_tool_name(name: str) -> str:
    """
    Convert tool name to valid Python identifier.

    Args:
        name: User-provided tool name.

    Returns:
        Valid Python identifier (lowercase, underscores).
    """
    # Replace hyphens and spaces with underscores
    name = name.replace("-", "_").replace(" ", "_")
    # Remove invalid characters
    name = "".join(c for c in name if c.isalnum() or c == "_")
    # Ensure doesn't start with number
    if name and name[0].isdigit():
        name = "_" + name
    return name.lower()


def format_param(arg_spec: tuple[str, str, str | None, str | None]) -> str:
    """Format a single parameter for the function signature."""
    name, arg_type, default, _ = arg_spec

    # Format default value based on type
    if default is not None:
        if arg_type == "str":
            default_str = f'"{default}"'
        elif arg_type == "bool":
            default_str = "True" if default.lower() in ("true", "1", "yes") else "False"
        else:
            default_str = default
        return f"    {name}: {arg_type} = {default_str},"
    else:
        return f"    {name}: {arg_type},"


def format_docstring_arg(arg_spec: tuple[str, str, str | None, str | None]) -> str:
    """Format a single argument for the docstring."""
    name, _, _, description = arg_spec
    desc = description or f"The {name} value."
    return f"        {name}: {desc}"


def generate_tool(
    name: str,
    wrap_command: str | None = None,
    tool_args: list[tuple[str, str, str | None, str | None]] | None = None,
    output_dir: Path | None = None,
    force: bool = False,
) -> tuple[bool, str, Path | None]:
    """
    Generate a new tool scaffold.

    Args:
        name: Tool name (will be converted to valid identifier).
        wrap_command: Optional shell command to wrap.
        tool_args: List of (name, type, default, description) tuples for custom args.
        output_dir: Output directory (default: ~/.l3m/tools/).
        force: Overwrite existing tool.

    Returns:
        Tuple of (success, message, tool_path).
    """
    output_dir = output_dir or USER_TOOLS_DIR
    function_name = generate_tool_name(name)

    if not function_name:
        return (False, f"Invalid tool name: {name}", None)

    tool_dir = output_dir / function_name
    init_file = tool_dir / "__init__.py"

    # Check if tool already exists
    if tool_dir.exists() and not force:
        return (
            False,
            f"Tool already exists: {tool_dir}\nUse --force to overwrite.",
            None,
        )

    # Create directory
    tool_dir.mkdir(parents=True, exist_ok=True)

    # Generate alias (first 3 chars or full name if short)
    alias = function_name[:3] if len(function_name) > 3 else function_name

    # Generate content
    if wrap_command:
        if tool_args:
            # Use template with custom arguments
            params = "\n".join(format_param(arg) for arg in tool_args)
            docstring_args = "\n".join(format_docstring_arg(arg) for arg in tool_args)
            # Build command args string: {arg1} {arg2} etc.
            cmd_args = " ".join(f"{{{arg[0]}}}" for arg in tool_args)
            arg_flags = " ".join(f'--arg "{arg[0]}:{arg[1]}"' for arg in tool_args)

            content = WRAPPER_ARGS_TOOL_TEMPLATE.format(
                tool_name=name,
                function_name=function_name,
                command=wrap_command,
                alias=alias,
                params=params,
                docstring_args=docstring_args,
                cmd_args=cmd_args,
                arg_flags=arg_flags,
            )
        else:
            content = WRAPPER_TOOL_TEMPLATE.format(
                tool_name=name,
                function_name=function_name,
                command=wrap_command,
                alias=alias,
                description=f"Wrapper for `{wrap_command}`",
            )
    else:
        content = BASIC_TOOL_TEMPLATE.format(
            tool_name=name,
            function_name=function_name,
            alias=alias,
            description=f"Custom tool: {name}",
        )

    # Write file
    init_file.write_text(content)

    return (True, f"Created tool at: {tool_dir}", tool_dir)
